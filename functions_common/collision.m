% 此函数用于检测带倒角的八边形车辆轮廓是否与障碍车碰撞

function r = collision(x,y,th,ku)

r = 0; % 碰撞风险

persistent a b c d e f g p1 p2 p3 p4 p5 p6 p7 p8 p9 p_all ego_A obs obs_A
persistent Tvr_inv 
% ---------------- 前后安全距离
persistent safe_r safe_f
if isempty(a)
    
% 先计算出8个角点的坐标
a = 0.16;
b = 0.365;
c = 1.551 - 2 * b;
d = 3.03;
e = 0.38;
f = 1.551 - 2 * e;
g = 0.544;

% 齐次坐标
p1 = [0 b 1];
p2 = [0 b+c 1];
p3 = [a 2*b+c 1];
p4 = [a+d 2*b+c 1];
p5 = [a+e+d f+e 1];
p6 = [a+d+e e 1];
p7 = [a+d 0 1];
p8 = [a 0 1 ];
p9 = [g b+c/2 1]; % 后轴中心
p_all = [p1; p2; p3;p4;p5;p6;p7;p8];

safe_r = 0.05;
safe_f = 0.05;

% 车的面积
ego_A = (2*b+c)*(a+e+d) - a*b - e*e;
% 障碍物坐标
obs = [0-safe_f 0; 5 0; 5 -2; 0-safe_f -2]'; % 安全距离视为障碍物的一部分面积
% 障碍物面积
obs_A = 10+safe_f*2;

Tvr_inv  = inv([1 0 g; 0 1 b+c/2; 0 0 1]);


end

% 旋转车辆
Twr = [cos(th) -sin(th) x; sin(th) cos(th) y; 0 0 1];

Twv = Twr*Tvr_inv;
p_all_w = Twv * p_all';


xmin = min(p_all_w(1,:));
ymin = min(p_all_w(2,:));
xmax = max(p_all_w(1,:));
ymax = max(p_all_w(2,:));

if xmin< -ku+safe_r
    r = 20000;
else % ------保证了后面不会撞到的前提
    if xmin >= -safe_f 
        %  情况二：整车都在库位前面
        if ymin > 0
            r = 0;
        else
            r = 20000;
        end
    else 
        if xmax >= -safe_f
            % 情况二：往x轴投影有重叠
            %        查看往车头方向的投影是否有重叠 原点指向车为投影轴的正方向 即7->4
            %    7指向4 是被投影的车的向量
            pp7 = p_all_w(:,7);
            pp4 = p_all_w(:,4);
            vector_head = pp4 - pp7;
            % 7这个点的投影坐标：
            cor_7 = (pp7(1) .* vector_head(1) + pp7(2) .* vector_head(2)) / sqrt(vector_head(1)^2 + vector_head(2)^2);
            % 障碍空间左上角点的投影坐标
            pf = [-safe_f 0];
            cor_f = (pf(1) .* vector_head(1) + pf(2) .* vector_head(2)) / sqrt(vector_head(1)^2 + vector_head(2)^2);
            if cor_7 >= cor_f
                r = 0;
            else
                r = 20000;
            end
        else
            % 情况三：往x轴投影没重影
            r = 0;
        end
    end
end

if ymin<=-2+0.1
    r= 20000;
end

%         if xmax > -safe_f 
%             r = 0;
%             %--
%             nn = 1;
%             S2 = mydet(obs(1, nn), obs(2, nn), ...
%                                     p_all_w(1,1), p_all_w(2,1) ,...
%                                     p_all_w(1,2), p_all_w(2,2) )  + ...
%                     mydet(obs(1, nn), obs(2, nn), ...
%                                     p_all_w(1,2), p_all_w(2,2), ...
%                                     p_all_w(1,3), p_all_w(2,3) ) +...
%                     mydet(obs(1, nn), obs(2, nn),...
%                                     p_all_w(1,3), p_all_w(2,3),...
%                                     p_all_w(1,4), p_all_w(2,4)) +...               
%                      mydet(obs(1, nn), obs(2, nn) , ...
%                                     p_all_w(1,4) ,p_all_w(2,4) ,...
%                                     p_all_w(1,5), p_all_w(2,5) ) +...              
%                     mydet(obs(1, nn) ,obs(2, nn),  ...
%                                     p_all_w(1,5), p_all_w(2,5) ,...
%                                     p_all_w(1,6), p_all_w(2,6) ) +... 
%                      mydet(obs(1, nn),obs(2, nn),  ...
%                                     p_all_w(1,6) ,p_all_w(2,6), ...
%                                     p_all_w(1,7), p_all_w(2,7) ) +...               
%                       mydet(obs(1, nn),obs(2, nn),...
%                                     p_all_w(1,7),p_all_w(2,7),...
%                                     p_all_w(1,8), p_all_w(2,8)) +...  
%                       mydet(obs(1, nn),obs(2, nn), p_all_w(1,8),p_all_w(2,8),...
%                                     p_all_w(1,1), p_all_w(2,1));  
%                         
%                 if 0.5*S2 <= ego_A + 0.01
%                     r = 20000;
%                 else
%                     r = 0;
%                 end
%         else
%                 r = 0;
%         end
%     end
% end



end
        %         % 车的点对于障碍物而言
        %         for k = [6 8] % 本应循环8次  但是往右泊车只有右边的点会撞到 为了减小计算量 只计算6 7 8 1 
        %                 S = 0.5 *  mydet( p_all_w(1, k),     p_all_w(2, k), ...
        %                                 obs(1, 1)   ,       obs(2, 1),...
        %                                  obs(1, 2), obs(2, 2) )  + ...
        %                 0.5 *  mydet( p_all_w(1, k)  ,   p_all_w(2, k), ...
        %                                 obs(1, 2) ,         obs(2, 2),...
        %                                  obs(1, 3), obs(2, 3))  +...
        %                 0.5 *  mydet( p_all_w(1, k)   ,  p_all_w(2, k), ...
        %                                 obs(1, 3)     ,     obs(2, 3) ,...
        %                                  obs(1, 4) ,obs(2, 4) )  +...
        %                 0.5 *  mydet( p_all_w(1, k) ,    p_all_w(2, k), ...
        %                                 obs(1, 4)   ,       obs(2, 4),...
        %                                  obs(1, 1) ,obs(2, 1) ) ;
        %                 if S <= obs_A + 0.01 % 安全值设置为0.01 比较小 大于  说明车的某个点在障碍车矩形内部
        %                     r = 20000;
        %                     break; % 退出循环
        %                 end
        %         end
        % --- 障碍物左上角点对于车而言
%         nn = 1;
%         S2 = mydet(obs(1, nn), obs(2, nn), ...
%                         p_all_w(1,1), p_all_w(2,1) ,...
%                         p_all_w(1,2), p_all_w(2,2) )  + ...
%         mydet(obs(1, nn), obs(2, nn), ...
%                         p_all_w(1,2), p_all_w(2,2), ...
%                         p_all_w(1,3), p_all_w(2,3) ) +...
%         mydet(obs(1, nn), obs(2, nn),...
%                         p_all_w(1,3), p_all_w(2,3),...
%                         p_all_w(1,4), p_all_w(2,4)) +...               
%          mydet(obs(1, nn), obs(2, nn) , ...
%                         p_all_w(1,4) ,p_all_w(2,4) ,...
%                         p_all_w(1,5), p_all_w(2,5) ) +...              
%         mydet(obs(1, nn) ,obs(2, nn),  ...
%                         p_all_w(1,5), p_all_w(2,5) ,...
%                         p_all_w(1,6), p_all_w(2,6) ) +... 
%          mydet(obs(1, nn),obs(2, nn),  ...
%                         p_all_w(1,6) ,p_all_w(2,6), ...
%                         p_all_w(1,7), p_all_w(2,7) ) +...               
%           mydet(obs(1, nn),obs(2, nn),...
%                         p_all_w(1,7),p_all_w(2,7),...
%                         p_all_w(1,8), p_all_w(2,8)) +...  
%           mydet(obs(1, nn),obs(2, nn), p_all_w(1,8),p_all_w(2,8),...
%                         p_all_w(1,1), p_all_w(2,1));  
%                         
%         if 0.5*S2 <= ego_A + 0.01
%             r = 20000;
%         else
%             r = 0;
%         end

% % 障碍物于车 本应循环4次 但是只有0 0这个点才可能撞到
% if r == 0
%     nn = 1;
%     S2 = mydet(obs(1, nn), obs(2, nn), ...
%                         p_all_w(1,1), p_all_w(2,1) ,...
%                         p_all_w(1,2), p_all_w(2,2) )  + ...
%         mydet(obs(1, nn), obs(2, nn), ...
%                         p_all_w(1,2), p_all_w(2,2), ...
%                         p_all_w(1,3), p_all_w(2,3) ) +...
%         mydet(obs(1, nn), obs(2, nn),...
%                         p_all_w(1,3), p_all_w(2,3),...
%                         p_all_w(1,4), p_all_w(2,4)) +...               
%          mydet(obs(1, nn), obs(2, nn) , ...
%                         p_all_w(1,4) ,p_all_w(2,4) ,...
%                         p_all_w(1,5), p_all_w(2,5) ) +...              
%         mydet(obs(1, nn) ,obs(2, nn),  ...
%                         p_all_w(1,5), p_all_w(2,5) ,...
%                         p_all_w(1,6), p_all_w(2,6) ) +... 
%          mydet(obs(1, nn),obs(2, nn),  ...
%                         p_all_w(1,6) ,p_all_w(2,6), ...
%                         p_all_w(1,7), p_all_w(2,7) ) +...               
%           mydet(obs(1, nn),obs(2, nn),...
%                         p_all_w(1,7),p_all_w(2,7),...
%                         p_all_w(1,8), p_all_w(2,8)) +...  
%           mydet(obs(1, nn),obs(2, nn), p_all_w(1,8),p_all_w(2,8),...
%                         p_all_w(1,1), p_all_w(2,1));  
%                         
%     if 0.5*S2 <= ego_A + 0.01
%         r = 20000;
%     end
% end
  
% end % func end

function d = mydet(x1,y1,x2,y2,x3,y3)
d = abs(x2*y3-y2*x3 + x3*y1-y3*x1 + x1*y2-y1*x2);
end